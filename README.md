# QRNG â€” Quantum Random Number Generator (Hackathon-Ready)

A production-style demo implementing a quantum random bit generator using the standard **Hadamard â†’ Measure** circuit,
with **post-processing extractors** (Von Neumann and SHA-256), a **randomness test suite** (monobit, runs, block
frequency, serial, approximate entropy, autocorrelation), and a **React dashboard** for live visualization.

> Designed to be presented as a _product_ (not just a circuit): real-time analytics, extractor pipeline, downloadable keys,
> JSON reports, Dockerized services, and a clean UI.

---

## Architecture

- **frontend/** â€” React (Vite) dashboard
  - Live charts for frequency, runs, autocorrelation
  - Controls for bit generation count, extractor selection
  - Report table with p-values + pass/fail
- **backend/** â€” FastAPI service
  - `/api/bits?n=...` â†’ raw quantum bits (Qiskit Aer if available; safe fallback to pseudo-random with banner)
  - `/api/extract` â†’ Von Neumann or SHA-256 extractor
  - `/api/key?len=256&method=sha256` â†’ 128/256-bit keys, salts, passwords
  - `/api/report` â†’ run tests and return a JSON report

> If Qiskit is installed, bits are generated by simulating `|0> --H--> measure` with `Aer` shots.
> If not installed (e.g., on judge machines without internet), the service **falls back** to a cryptographically secure PRNG
> (Python `secrets`) and responds with a **warning flag**. This preserves demo flow while keeping the code quantum-ready.

---

## Quick Start (Dev)

### 1) Backend
```bash
cd backend
python -m venv .venv && source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -r requirements.txt
uvicorn app:app --host 0.0.0.0 --port 8000 --reload
```

Optional (quantum backend):
```bash
pip install qiskit qiskit-aer
```

### 2) Frontend
```bash
cd frontend
npm install
npm run dev
```

Open: http://localhost:5173

---

## Docker (One Command)

```bash
docker compose up --build
```

- Frontend: http://localhost:5173
- Backend: http://localhost:8000/docs

---

## API (FastAPI)

- `GET /api/health`
- `GET /api/bits?n=100000` â†’ `{ "bits": "01001...", "count": n, "quantum": true|false, "note": "...optional warning..." }`
- `POST /api/extract` â†’ body: `{ "bits": "0101...", "method": "von_neumann" | "sha256" }`
- `GET /api/key?len=256&method=sha256`
- `POST /api/report` â†’ body: `{ "bits": "0101..." }`

---

## Tests Implemented

- **Monobit** (proportion of ones, z-test)
- **Runs** (number of runs vs expected)
- **Block Frequency** (chi-square, configurable block size)
- **Serial** (order-2 frequencies of 00/01/10/11)
- **Approximate Entropy** (ApEn for m, m+1)
- **Autocorrelation** (fixed lags set)

> These are fast, hackathon-friendly approximations inspired by NIST SP 800-22. Do not present as a full NIST certification.

---

## Security Notes

- Donâ€™t claim â€œprovably secureâ€ unless using a proper strong extractor with adequate entropy bounds.
- This demo provides **Von Neumann** (debias) and **SHA-256** (hash-based extractor). Consider **Toeplitz hashing** as stretch.
- Key material is never logged; only a checksum is returned for display.

---

## Folder Layout

```
qrng-project/
  backend/
    app.py
    requirements.txt
    routers/
      bits.py
      extract.py
      key.py
      report.py
    qrng/
      __init__.py
      generator.py
      extractor.py
      tests.py
      report.py
    Dockerfile
  frontend/
    index.html
    package.json
    vite.config.js
    src/
      main.jsx
      App.jsx
      components/
        Dashboard.jsx
        PValueTable.jsx
      services/
        api.js
    Dockerfile
  docker-compose.yml
  README.md
```

---

## Judge Demo Script (2 minutes)

1. **Generate 1,000,000 bits** â†’ see frequency hover around 50%, runs distribution, autocorrelation near 0.
2. **Apply SHA-256 extractor** â†’ bias collapses, show before/after metrics.
3. **Open Report** â†’ green pass flags with p-values.
4. **Generate 256-bit key** â†’ show hex + checksum + download; note â€œno loggingâ€.

Good luck! ğŸš€
